/**
 * MyOwnDB SDK v1.0.0 | MIT License
 * https://github.com/parth123-coder/MyOwnDb
 */
!function (r, t) { "function" == typeof define && define.amd ? define([], t) : "object" == typeof module && module.exports ? module.exports = t() : r.MyOwnDB = t() }("undefined" != typeof self ? self : this, function () { "use strict"; const VERSION = "1.0.0"; class QueryBuilder { constructor(r, t) { this.db = r, this.tableName = t, this.queryParams = { limit: null, offset: null, search: null, sort: null, order: "asc" }, this.filters = [] } where(r, t, e = null) { let s = "=", i = t; null !== e && (s = t, i = e); let n = ""; switch (s.toUpperCase()) { case "=": n = ""; break; case ">": n = "__gt"; break; case "<": n = "__lt"; break; case ">=": n = "__gte"; break; case "<=": n = "__lte"; break; case "!=": n = "__ne"; break; case "LIKE": n = "__contains"; break; case "ILIKE": n = "__icontains"; break; default: n = "" }return this.filters.push(`${r}${n}=${encodeURIComponent(i)}`), this } orderBy(r, t = "asc") { return this.queryParams.sort = r, this.queryParams.order = t, this } limit(r) { return this.queryParams.limit = r, this } offset(r) { return this.queryParams.offset = r, this } search(r, t) { return this.queryParams.search = t, this } select(r = null) { return r && this.limit(r), this } async execute() { let r = Object.entries(this.queryParams).filter(([r, t]) => null !== t).map(([r, t]) => `${r}=${encodeURIComponent(t)}`).join("&"); this.filters.length > 0 && (r += (r ? "&" : "") + this.filters.join("&")); const t = await this.db._request(`/tables/${this.tableName}/rows/?${r}`); return t.data ? { data: t.data.rows, error: null, count: t.data.total, pagination: { page: t.data.page, limit: t.data.limit, total_pages: t.data.total_pages } } : t } then(r, t) { return this.execute().then(r, t) } async insert(r) { return await this.db._request(`/tables/${this.tableName}/rows/`, { method: "POST", body: JSON.stringify(r) }) } async update(r, t) { return await this.db._request(`/tables/${this.tableName}/rows/${r}/`, { method: "PUT", body: JSON.stringify(t) }) } async delete(r) { return await this.db._request(`/tables/${this.tableName}/rows/${r}/`, { method: "DELETE" }) } async addColumn(r) { return await this.db._request(`/tables/${this.tableName}/columns/`, { method: "POST", body: JSON.stringify(r) }) } async schema() { return await this.db._request(`/tables/${this.tableName}/`) } } class MyOwnDB { constructor(r, t = "http://127.0.0.1:8000/api/v1") { this.apiKey = r, this.baseUrl = t.replace(/\/$/, "") } from(r) { return new QueryBuilder(this, r) } async _request(r, t = {}) { const e = `${this.baseUrl}${r}`, s = { headers: { "X-API-Key": this.apiKey, "Content-Type": "application/json" }, ...t }; try { const r = await fetch(e, s), t = await r.json(); return r.ok ? { data: t, error: null } : { data: null, error: t.error || t.detail || "Request failed" } } catch (r) { return { data: null, error: r.message } } } async tables() { const r = await this._request("/tables/"); return r.data ? { data: r.data.tables, error: null } : r } async createTable(r, t) { let e = t; return Array.isArray(t) || (e = Object.entries(t).map(([r, t]) => ({ name: r, type: t }))), await this._request("/tables/", { method: "POST", body: JSON.stringify({ name: r, columns: e }) }) } } return MyOwnDB.VERSION = VERSION, MyOwnDB });
